<script lang="ts">
    import type { MediaStyle } from "../../../types/Main"
    import { activeProject, activeRename, dictionary, focusMode, outLocked, outputs, playingVideos, projects, videoMarkers, videosData, videosTime, volume } from "../../stores"
    import Icon from "../helpers/Icon.svelte"
    import T from "../helpers/T.svelte"
    import { analyseAudio, getAnalyser } from "../helpers/audio"
    import { getActiveOutputs, setOutput } from "../helpers/output"
    import { joinTime, secondsToTime } from "../helpers/time"
    import Button from "../inputs/Button.svelte"
    import HiddenInput from "../inputs/HiddenInput.svelte"
    import HoverButton from "../inputs/HoverButton.svelte"
    import VideoSlider from "../output/VideoSlider.svelte"
    import MediaControls from "../output/tools/MediaControls.svelte"
    import Player from "../system/Player.svelte"

    export let show

    $: showId = show?.id
    $: type = show?.type

    // show updates when videoTime updates for some reason?
    // $: console.trace(show)
    // $: console.trace(videoTime)

    export let mediaStyle: MediaStyle = {}

    let videoTime: number = 0
    let videoData = {
        paused: false,
        muted: true,
        duration: 0,
        loop: false,
    }
    $: if (!videoData) videoData = { paused: false, muted: true, duration: 0, loop: false }
    $: if (playingInOutput && $videosData[outputId]) setVideoData()
    $: if (playingInOutput && $videosData[outputId]?.paused && !videoData.paused) setPaused()
    function setPaused() {
        videoData.paused = true
        // trigger time update
        videoTime = 0
    }
    function setVideoData() {
        videoData = { ...$videosData[outputId], muted: true }
    }

    let prevId: string | undefined = undefined
    $: if (showId !== prevId) {
        videoTime = 0
        autoPause = true
        prevId = showId

        timeMarkersEnabled = !!$videoMarkers[showId]?.length || false
    }

    $: outputId = getActiveOutputs($outputs, false, true, true)[0]
    $: currentOutput = $outputs[outputId]

    // outBackground.subscribe(backgroundChanged)
    $: background = currentOutput?.out?.background || {}
    $: if (background || showId) backgroundChanged()
    let playingInOutput: boolean = false
    function backgroundChanged() {
        // background = currentOutput?.out?.background || {}
        // || videoData.paused
        if (background === null || (background.path || background.id) !== showId) {
            playingInOutput = false
            return
        }
        // if (background.type !== "media" && background.type !== "video") return

        autoPause = true
        // videoData.paused = true
        playingInOutput = true

        // trigger time update
        setTimeout(() => (videoTime = 0), 50)
    }
    $: if (playingInOutput && Math.abs(videoTime - $videosTime[outputId]) > 1) updateVideoTime()
    function updateVideoTime() {
        // get and set actual time
        videoTime = $videosTime[outputId]
    }

    // WIP toggle between output/preview video...
    // WIP player video output time

    // $: if (background.path === showId && autoPause) videoData.paused = true

    let autoPause: boolean = true
    let hasLoaded: boolean = false

    let previewControls: boolean = false
    let timeMarkersEnabled: boolean = false

    function onLoad() {
        hasLoaded = true
        if (videoData.paused) return

        if ($focusMode) {
            // set right after loaded
            setTimeout(() => {
                videoData.paused = true
                videoTime = videoData.duration ? videoData.duration / 2 : 0
            })
            return
        }

        if (autoPause) videoData.paused = false
        else videoTime = 0
    }

    // player
    $: if (type === "player") playerLoad()
    function playerLoad() {
        if (!$focusMode) return

        // timeout for loading, because if the video is not loaded in time it will start playing, but that's fine
        setTimeout(() => {
            videoData.paused = true
            videoTime = videoData.duration ? videoData.duration / 2 : 0
        }, 2000)
    }

    let video: any
    async function onPlay() {
        // autoPause = false
        if (hasLoaded) {
            if (!playingInOutput) videoTime = 0
            hasLoaded = false

            let analyser = await getAnalyser(video)
            if (!analyser) return

            playingVideos.update((a) => {
                a.push({ id: showId, location: "preview", analyser })
                return a
            })
            analyseAudio()
        }
    }
    // $: if (videoData) {
    //     playingVideos.update((a) => {
    //         let existing = a.findIndex((a) => a.id === showId && a.location === "preview")
    //         if (existing > -1) {
    //             a[existing].paused = videoData.muted ? true : videoData.paused
    //             if (!a[existing].paused) analyseAudio()
    //         }
    //         return a
    //     })
    // }

    function keydown(e: any) {
        if (e.target.closest("input") || e.target.closest(".edit")) return

        let output = $outputs[getActiveOutputs()[0]] || {}
        let outputPath = output.out?.background?.path

        if (e.key === " " && !$focusMode && show && (!outputPath || outputPath !== showId)) {
            e.preventDefault()
            if ((type === "video" && outputPath !== showId) || (type === "player" && output.out?.background?.id !== showId)) playVideo()
            else if (type === "image" && !$outLocked) setOutput("background", { path: showId, ...mediaStyle })
            // TODO: this will play first slide
            // else if (type === "section") goToNextProjectItem()
        }
    }

    function playVideo(startAt: number = 0) {
        if ($outLocked) return

        let bg: any = { type: type, startAt, muted: false, loop: false, ...mediaStyle }

        if (type === "player") bg.id = showId
        else {
            bg.path = showId
            // if (filter) data.filter = filter
        }

        // autoPause = true
        // videoData.paused = true

        // TODO: playing in multiple outputs will create unclearable "ghost" video

        if ($activeProject && $projects[$activeProject].shows.find((a) => a.id === bg.path)) setOutput("slide", null)
        setOutput("background", bg)
    }

    $: if (video && mediaStyle.speed) video.playbackRate = mediaStyle.speed

    // MARKER

    // TODO: history
    function addMarker() {
        videoMarkers.update((a) => {
            const newMarker = { name: "", time: Math.floor(videoTime || 0) }

            if (a[showId]?.find((a) => a.time === newMarker.time)) return a

            if (!a[showId]) a[showId] = []
            a[showId].push(newMarker)

            // sort by time
            a[showId] = a[showId].sort((a, b) => a.time - b.time)

            let markerIndex = a[showId].findIndex((a) => a.time === newMarker.time)
            activeRename.set("marker_" + markerIndex)

            return a
        })
    }

    let edit: boolean = false

    function changeName(e: any) {
        let currentMarker = e.detail?.id?.slice("marker_".length)
        if (currentMarker === undefined) return

        videoMarkers.update((a) => {
            a[showId][currentMarker].name = e.detail.value

            return a
        })
        // history({ id: "UPDATE", newData: { key: "layouts", keys: [currentLayout], subkey: "name", data: e.detail.value }, oldData: { id: showId }, location: { page: "show", id: "show_key" } })
    }

    let pausedByEdit: boolean = false
    $: if (edit) {
        if (!videoData.paused) {
            videoData.paused = true
            pausedByEdit = true
        }
    } else if (pausedByEdit) {
        videoData.paused = false
        pausedByEdit = false
    }
</script>

<svelte:window on:keydown={keydown} />

{#key showId}
    <div class="media context #media_preview" style="flex: 1;overflow: hidden;">
        <!-- TODO: info about: CTRL click to play at current pos -->
        <HoverButton icon="play" size={10} on:click={(e) => playVideo(e.ctrlKey || e.metaKey ? videoTime : 0)} title={$dictionary.media?.play}>
            {#if type === "player"}
                <Player id={showId} bind:videoData bind:videoTime preview />
            {:else}
                <!-- TODO: on:error={videoError} - ERR_FILE_NOT_FOUND -->
                <video
                    style="width: 100%;height: 100%;filter: {mediaStyle.filter || ''};transform: scale({mediaStyle.flipped ? '-1' : '1'}, {mediaStyle.flippedY ? '-1' : '1'});"
                    src={showId}
                    on:loadedmetadata={onLoad}
                    on:playing={onPlay}
                    bind:this={video}
                    bind:currentTime={videoTime}
                    bind:paused={videoData.paused}
                    bind:duration={videoData.duration}
                    bind:muted={videoData.muted}
                    bind:volume={$volume}
                >
                    <track kind="captions" />
                </video>
            {/if}
        </HoverButton>
    </div>

    {#if playingInOutput ? $videoMarkers[showId]?.length : timeMarkersEnabled}
        <div class="buttons" style="display: flex;">
            <div class="markers">
                {#if $videoMarkers[showId]?.length}
                    {#each $videoMarkers[showId] as marker, i}
                        <Button
                            class="context #video_marker"
                            id={i}
                            on:click={() => {
                                if (!edit) {
                                    playVideo(marker.time || 0)
                                }
                            }}
                            bold={false}
                            center
                            dark
                        >
                            <p style="display: flex;align-items: center;">
                                <HiddenInput value={marker.name} id={"marker_" + i} on:edit={changeName} bind:edit />
                                <span style="opacity: 0.7;">{joinTime(secondsToTime(marker.time))}</span>
                            </p>
                        </Button>
                    {/each}
                {:else}
                    <p style="opacity: 0.7;text-align: center;width: 100%;"><T id="empty.general" /></p>
                {/if}
            </div>

            {#if previewControls && !playingInOutput}
                <Button on:click={addMarker}>
                    <Icon id="add" right />
                    <p><T id="actions.add_time_marker" /></p>
                </Button>
            {/if}
        </div>
    {/if}

    {#if playingInOutput}
        <MediaControls {currentOutput} {outputId} big />
    {:else if previewControls}
        <div class="buttons" style="display: flex;">
            <Button
                style="flex: 0;"
                center
                title={videoData.paused ? $dictionary.media?.play : $dictionary.media?.pause}
                on:click={() => {
                    autoPause = false
                    videoData.paused = !videoData.paused
                }}
            >
                <Icon id={videoData.paused ? "play" : "pause"} white={videoData.paused} size={1.2} />
            </Button>
            <VideoSlider bind:videoData bind:videoTime />
            <Button style="flex: 0;" center title={videoData.muted ? $dictionary.actions?.unmute : $dictionary.actions?.mute} on:click={() => (videoData.muted = !videoData.muted)}>
                <Icon id={videoData.muted ? "muted" : "volume"} white={videoData.muted} size={1.2} />
            </Button>
            <Button style="flex: 0;" title={$dictionary.actions?.toggle_time_marker} on:click={() => (timeMarkersEnabled = !timeMarkersEnabled)} center>
                <Icon id="timeMarker" white={!timeMarkersEnabled} size={1.2} />
            </Button>
        </div>
    {:else if !$focusMode && !playingInOutput}
        <Button on:click={() => (previewControls = true)} style="background-color: var(--primary-darkest);" center dark>
            <Icon id="eye" right />
            <T id="preview.enable_controls" />
        </Button>
    {/if}
{/key}

<style>
    .buttons {
        background-color: var(--primary-darkest);
    }

    .buttons :global(.slider input) {
        background-color: var(--primary);
    }

    .markers {
        flex: 1;
        /* padding: 0 10px; */
        display: flex;
        justify-content: space-between;
        align-items: center;
        overflow-x: auto;
    }

    .markers :global(button) {
        flex: 1;
    }
</style>
