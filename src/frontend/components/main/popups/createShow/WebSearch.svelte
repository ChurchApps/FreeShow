<script lang="ts">
    import { createEventDispatcher, onDestroy, onMount } from "svelte"
    import { Main } from "../../../../../types/IPC/Main"
    import type { LyricSearchResult } from "../../../../../types/Main"
    import { destroyMain, receiveMain, sendMain } from "../../../../IPC/main"
    import { dictionary, special } from "../../../../stores"
    import { newToast } from "../../../../utils/common"
    import Icon from "../../../helpers/Icon.svelte"
    import T from "../../../helpers/T.svelte"
    import Button from "../../../inputs/Button.svelte"
    import Center from "../../../system/Center.svelte"
    import Loader from "../../Loader.svelte"

    export let query: string

    let songs: LyricSearchResult[] | null = null

    let loading = false
    // let loadTimeout: NodeJS.Timeout | null = null
    onMount(searchLyrics)
    function searchLyrics() {
        let artist = ""
        let title = query
        if (!title) {
            newToast("$toast.no_name")
            return
        }

        sendMain(Main.SEARCH_LYRICS, { artist, title })
        loading = true

        // loadTimeout = setTimeout(() => {
        //     newToast("timed out")
        //     setValue("")
        // }, 20000)
    }

    function getLyrics(song: LyricSearchResult) {
        sendMain(Main.GET_LYRICS, { song })
        loading = true
    }

    // encode using btoa()
    const blockedWords = ["ZnVjaw==", "Yml0Y2g=", "bmlnZ2E="]
    const blockedArtists = ["R2hvc3Q=", "R2VuZXNpcw==", "QUMvREM=", "RGlzdHVyYmVk", "Qm9iIFJpdmVycw==", "Q2FyeSBBbm4gSGVhcnN0"]
    let listenerIdSearch = receiveMain(Main.SEARCH_LYRICS, (data) => {
        data = filterBadArtists(data)

        if (!data.length) {
            newToast("$empty.search")
            setValue("")
        }

        loading = false
        songs = data
    })
    let listenerIdLyrics = receiveMain(Main.GET_LYRICS, (data) => {
        loading = false

        // filter out songs with bad words
        blockedWords.forEach((eWord) => {
            let word = atob(eWord)
            if (data.lyrics.includes(word)) data.lyrics = ""
        })

        if (!data.lyrics) {
            newToast("$toast.lyrics_undefined")
            setValue("")
            return
        }

        setValue(data)
        newToast($dictionary.toast?.lyrics_copied + " " + data.source + "!")
    })
    onDestroy(() => {
        destroyMain(listenerIdSearch)
        destroyMain(listenerIdLyrics)
    })

    function filterBadArtists(data: LyricSearchResult[]) {
        return data.filter(
            (a) =>
                !blockedArtists.find((eArtist) => {
                    const artist = atob(eArtist)
                    return a.artist && a.artist === artist
                }) && !($special.blockedArtists || []).includes(a.artist)
        )
    }

    let dispatch = createEventDispatcher()
    function setValue(data: any) {
        dispatch("update", data)
    }

    let tempBlocked: string[] = []
    function blockArtist(artist: string) {
        const undo = tempBlocked.includes(artist)

        special.update((a) => {
            if (!a.blockedArtists) a.blockedArtists = []

            if (undo) {
                const index = a.blockedArtists.indexOf(artist)
                if (index > -1) a.blockedArtists.splice(index, 1)
            } else {
                a.blockedArtists.push(artist)
            }

            return a
        })

        if (undo) {
            tempBlocked.splice(tempBlocked.indexOf(artist), 1)
        } else {
            tempBlocked.push(artist)
        }
        tempBlocked = tempBlocked

        // if (songs) songs = filterBadArtists(songs)
    }
</script>

{#if loading}
    <Center style="overflow: hidden;">
        <Loader />
    </Center>
{:else if songs !== null}
    <div class="header">
        <Icon id="search" white right />
        <T id="create_show.search_results" />
    </div>

    <div style="max-height: 250px;overflow-y: auto;display: flex;">
        <table class="searchResultTable">
            <thead>
                <tr>
                    <th><T id="show.song" /></th>
                    <th><T id="show.artist" /></th>
                    <th><T id="show.source" /></th>
                </tr>
            </thead>
            <tbody>
                {#if songs}
                    {#each songs as song}
                        {@const blocked = tempBlocked.includes(song.artist)}
                        <tr
                            on:click={(e) => {
                                if (e.target?.closest("button") || e.target?.closest("path")) return
                                getLyrics(song)
                            }}
                        >
                            <td class="title">{song.title}</td>
                            <td class="flex-table" style={blocked ? "text-decoration: line-through;" : ""}>
                                {song.artist}
                                {#if song.artist && song.source !== "Hymnary"}
                                    <Button title={blocked ? $dictionary.actions?.undo : $dictionary.create_show?.block} style="padding: 2px;" on:click={() => blockArtist(song.artist)}>
                                        <Icon style="opacity: 0.4;" id={blocked ? "undo" : "block"} white />
                                    </Button>
                                {/if}
                            </td>
                            <td>{song.source}</td>
                        </tr>
                    {/each}
                {:else}
                    <tr>
                        <td colspan="3">No songs found</td>
                    </tr>
                {/if}
            </tbody>
        </table>
    </div>
{/if}

<style>
    .header {
        display: flex;
        align-items: center;
        justify-content: center;

        font-size: 0.9em;
        padding: 5px 0;
        background: var(--primary-darkest);
        font-weight: 600;
        opacity: 0.9;
    }

    .searchResultTable {
        flex: 1;
        table-layout: fixed;
        border-spacing: 0;

        background-color: var(--primary-darker);
    }

    .searchResultTable th {
        text-align: start;
        font-size: 0.8em;
        font-weight: bold;
        padding: 2px 10px;
    }

    .searchResultTable td {
        font-size: 0.8em;
        padding: 2px 10px;
        overflow: hidden;
        white-space: noWrap;
    }

    .searchResultTable tbody tr:nth-child(odd) {
        background-color: var(--hover);
    }

    .searchResultTable tbody tr:hover {
        background-color: var(--focus);
        cursor: pointer;
    }

    .searchResultTable td:first-of-type,
    .searchResultTable th:first-of-type {
        width: 64%;
    }
    .searchResultTable td:nth-of-type(2),
    .searchResultTable th:nth-of-type(2) {
        width: 22%;
    }

    .searchResultTable td:nth-of-type(3),
    .searchResultTable th:nth-of-type(3) {
        width: 14%;
    }

    .searchResultTable td.flex-table {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 5px;
        width: 100%;
    }

    .searchResultTable .title {
        font-weight: 600;
        color: var(--secondary);
    }
</style>
